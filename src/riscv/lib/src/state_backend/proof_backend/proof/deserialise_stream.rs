// SPDX-FileCopyrightText: 2025 TriliTech <contact@trili.tech>
//
// SPDX-License-Identifier: MIT

use std::cell::RefCell;
use std::collections::VecDeque;
use std::io::Read;
use std::marker::PhantomData;
use std::rc::Rc;

use serde::de::DeserializeOwned;

use super::DeserialiseError;
use super::LeafTag;
use super::Tag;
use super::deserialiser::DeserError;
use super::deserialiser::Deserialiser;
use super::deserialiser::DeserialiserNode;
use super::deserialiser::Partial;
use super::deserialiser::Result;
use super::deserialiser::Suspended;
use crate::state_backend::AllocatedOf;
use crate::state_backend::ProofLayout;
use crate::state_backend::verify_backend::Verifier;
use crate::storage::Hash;

/// Wrapper type over the raw byte data to parse tags.
pub struct TagIter<'i> {
    buffered_tags: VecDeque<Result<Tag, DeserialiseError>>,
    raw_data_iter: std::io::Cursor<&'i [u8]>,
}

impl Iterator for TagIter<'_> {
    type Item = Result<Tag, DeserialiseError>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buffered_tags.is_empty() {
            // We have to consume the next byte
            let mut next_byte = [0u8];
            let byte = match self.raw_data_iter.read_exact(&mut next_byte) {
                Ok(()) => next_byte[0],
                Err(_eof) => return None,
            };
            let tags = Tag::ordered_tags_from_u8(byte);
            self.buffered_tags.extend(tags);
        }
        self.buffered_tags.pop_front()
    }
}
impl<'i> TagIter<'i> {
    /// Create a [`TagIter`] from a `&[u8]`
    pub fn new(raw_data: &'i [u8]) -> Self {
        TagIter {
            buffered_tags: VecDeque::new(),
            raw_data_iter: std::io::Cursor::new(raw_data),
        }
    }
    /// Convert the remaining unparsed bytes as a [`StreamInput`] for further deserialising.
    pub fn remaining_to_stream_input(&self) -> StreamInput<'_> {
        StreamInput {
            // This clone only copies the reference and the position, not the whole byte array.
            cursor: self.raw_data_iter.clone(),
        }
    }
}

/// Input used for the suspended computation generated by [`StreamDeserialiser`]
pub struct StreamInput<'cd> {
    cursor: std::io::Cursor<&'cd [u8]>,
}

impl StreamInput<'_> {
    /// Interpret the next bytes as `T` using [`DeserializeOwned`].
    fn deserialise<T: DeserializeOwned>(&mut self) -> Result<T> {
        Ok(crate::storage::binary::deserialise_from(&mut self.cursor)?)
    }
}

/// Deserialiser for [`Deserialiser`] based on a stream of bytes.
#[derive(Clone)]
pub enum StreamDeserialiser<'t> {
    Absent,
    Present { tags: Rc<RefCell<TagIter<'t>>> },
}

impl<'t> Deserialiser for StreamDeserialiser<'t> {
    type Suspended<R> = StreamParserComb<'t, R>;

    type DeserialiserNode<R> = StreamBranchComb<'t, R>;

    fn into_leaf_raw<const LEN: usize>(self) -> Result<Self::Suspended<Partial<Box<[u8; LEN]>>>> {
        let tag = match self.next_tag() {
            None => {
                return Ok(StreamParserComb::new(|_| Ok(Partial::Absent)));
            }
            Some(tag) => tag?,
        };
        Ok(StreamParserComb::new(match tag {
            Tag::Node => return Err(DeserError::UnexpectedNode),
            Tag::Leaf(leaf_type) => move |input: &mut StreamInput| match leaf_type {
                LeafTag::Blind => Ok(Partial::Blinded(input.deserialise::<Hash>()?)),
                LeafTag::Read => {
                    let mut data = Box::new([0_u8; LEN]);
                    match input.cursor.read_exact(data.as_mut()) {
                        Ok(()) => Ok(Partial::Present(data)),
                        Err(_eof) => Err(DeserialiseError::NotEnoughBytes.into()),
                    }
                }
            },
        }))
    }

    fn into_leaf<T: DeserializeOwned>(self) -> Result<Self::Suspended<Partial<T>>> {
        let tag = match self.next_tag() {
            None => {
                return Ok(StreamParserComb::new(|_| Ok(Partial::Absent)));
            }
            Some(tag) => tag?,
        };
        Ok(StreamParserComb::new(match tag {
            Tag::Node => return Err(DeserError::UnexpectedNode),
            Tag::Leaf(leaf_type) => move |input: &mut StreamInput| match leaf_type {
                LeafTag::Blind => Ok(Partial::Blinded(input.deserialise::<Hash>()?)),
                LeafTag::Read => Ok(Partial::Present(input.deserialise::<T>()?)),
            },
        }))
    }
    fn into_node(self) -> Result<Self::DeserialiserNode<Partial<()>>> {
        let tags = match self {
            StreamDeserialiser::Absent => {
                return Ok(StreamBranchComb {
                    f: Box::new(|_| Ok(Partial::Absent)),
                    node_state: None,
                });
            }
            StreamDeserialiser::Present { tags } => tags,
        };

        let tag = tags
            .borrow_mut()
            .next()
            .ok_or(DeserialiseError::NotEnoughBytes)??;

        match tag {
            Tag::Leaf(LeafTag::Read) => Err(DeserError::UnexpectedLeaf),
            Tag::Leaf(LeafTag::Blind) => Ok(StreamBranchComb {
                f: Box::new(move |input: &mut StreamInput| {
                    Ok(Partial::Blinded(input.deserialise()?))
                }),
                node_state: None,
            }),
            Tag::Node => Ok(StreamBranchComb {
                f: Box::new(|_| Ok(Partial::Present(()))),
                node_state: Some(tags),
            }),
        }
    }
}

impl<'t> StreamDeserialiser<'t> {
    /// Create a new [`StreamDeserialiser::Present`] with the given tags.
    pub fn new_present(tags: Rc<RefCell<TagIter<'t>>>) -> Self {
        StreamDeserialiser::Present { tags }
    }

    /// Obtain next tag.
    ///
    /// Return [`None`] if the parent node is absent / blinded - making it nonsensical
    /// to obtain any tags.  
    fn next_tag(&self) -> Option<Result<Tag, DeserialiseError>> {
        // Panic: Never actually panics because the mutable borrow is first used only while deserialising,
        // Only after all tags are parsed the mutable borrow is used when running the Suspended computation.
        // Since the deserialiser & suspended traits never expose a way for running the suspended computation
        // this guarantees the sequential use of mutable borrows.
        match self {
            StreamDeserialiser::Absent => None,
            StreamDeserialiser::Present { tags } => Some(match tags.borrow_mut().next() {
                None => Err(DeserialiseError::NotEnoughBytes),
                Some(tag) => tag,
            }),
        }
    }
}

/// Parser combinator for [`StreamDeserialiser`] deserialiser.
pub struct StreamParserComb<'t, R> {
    #[expect(
        clippy::type_complexity,
        reason = "FnOnce is a trait and trait aliases are not stable yet"
    )]
    f: Box<dyn FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'static>,
    _pd: PhantomData<fn(StreamInput<'t>)>,
}

impl<'t, R> Suspended for StreamParserComb<'t, R> {
    type Output = R;

    type Parent = StreamDeserialiser<'t>;

    fn map<T>(
        self,
        map_f: impl FnOnce(Self::Output) -> T + 'static,
    ) -> <Self::Parent as Deserialiser>::Suspended<T>
    where
        Self::Output: 'static,
    {
        StreamParserComb::new(move |input| {
            let r = (self.f)(input)?;
            Ok(map_f(r))
        })
    }
}

impl<R> StreamParserComb<'_, R> {
    /// Create a new [`StreamParserComb`] with the given function.
    pub fn new(f: impl FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'static) -> Self {
        StreamParserComb {
            f: Box::new(f),
            _pd: PhantomData,
        }
    }
}

/// Branch combinator for [`StreamDeserialiser`] deserialiser.
pub struct StreamBranchComb<'t, R> {
    #[expect(
        clippy::type_complexity,
        reason = "FnOnce is a trait and trait aliases are not stable yet"
    )]
    f: Box<dyn FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'static>,
    /// The none case represents that the father node was blind or absent.
    node_state: Option<Rc<RefCell<TagIter<'t>>>>,
}

impl<'t, R> DeserialiserNode<R> for StreamBranchComb<'t, R> {
    type Parent = StreamDeserialiser<'t>;

    fn next_branch<T>(
        self,
        branch_deserialiser: impl FnOnce(
            Self::Parent,
        )
            -> Result<<Self::Parent as Deserialiser>::Suspended<T>>,
    ) -> Result<<Self::Parent as Deserialiser>::DeserialiserNode<(R, T)>>
    where
        T: 'static,
        R: 'static,
    {
        let child_proof = match &self.node_state {
            Some(tags) => StreamDeserialiser::new_present(tags.clone()),
            None => StreamDeserialiser::Absent,
        };
        let next_branch_fn = branch_deserialiser(child_proof)?;

        Ok(StreamBranchComb {
            f: Box::new(move |input| {
                // We still have to apply the parser combinator, it may compute the Hash for the blinded case for example
                // or any other intermediate function the user made on the computation using `map`
                let r = (self.f)(input)?;

                // The same logic applies for the child branch, maybe the user maps the Absent result to something else.
                let br_res = (next_branch_fn.f)(input)?;

                Ok((r, br_res))
            }),
            node_state: self.node_state,
        })
    }

    fn map<T>(
        self,
        f: impl FnOnce(R) -> T + 'static,
    ) -> <Self::Parent as Deserialiser>::DeserialiserNode<T>
    where
        T: 'static,
        R: 'static,
    {
        StreamBranchComb {
            f: Box::new(move |input| Ok(f((self.f)(input)?))),
            node_state: self.node_state,
        }
    }

    fn done(self) -> Result<<Self::Parent as Deserialiser>::Suspended<R>> {
        Ok(StreamParserComb {
            f: self.f,
            _pd: PhantomData,
        })
    }
}

impl<R> StreamParserComb<'_, R> {
    /// Deserialise the input and return the result if all bytes have been consumed.  
    pub fn into_result(self, input: &mut StreamInput) -> Result<R> {
        let result = (self.f)(input);

        // A correct deserialisation makes sure all bytes are consumed.
        // Otherwise, if tags dictate more a bigger part of the proof has been blinded then
        // the extra data at the end which wasn't actually blinded remains unparsed / ignored.

        // XXX: has_data_left() can be used, but it is a nightly feature
        // tracking issue: <https://github.com/rust-lang/rust/issues/86423>
        let mut next_byte = [0_u8];
        match input.cursor.read_exact(&mut next_byte) {
            Ok(()) => Err(DeserError::RemainingBytes),
            Err(_eof) => result,
        }
    }
}

/// Deserialise into a type `T::Output` given the raw bytes.
///
/// Convenience function to bundle deserialisation and execution of the suspended function for the owned deserialisation.
pub fn deserialise<L: ProofLayout>(
    proof_tree_raw_bytes: &[u8],
) -> Result<AllocatedOf<L, Verifier>, DeserError> {
    let tags_rc = Rc::new(RefCell::new(TagIter::new(proof_tree_raw_bytes)));
    let comp_fn = L::to_verifier_alloc(StreamDeserialiser::new_present(tags_rc.clone()))?;

    // SAFETY: The `Deserialiser` trait provided to the `FromProof` implementation of T
    // can not execute the suspended computation, it can only compose them due to encapsulation
    (comp_fn.f)(&mut tags_rc.borrow_mut().remaining_to_stream_input())
}
