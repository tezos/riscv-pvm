// SPDX-FileCopyrightText: 2025 TriliTech <contact@trili.tech>
//
// SPDX-License-Identifier: MIT

use std::cell::RefCell;
use std::collections::VecDeque;
use std::io::Read;
use std::marker::PhantomData;
use std::rc::Rc;

use serde::de::DeserializeOwned;

use super::DeserialiseError;
use super::LeafTag;
use super::Tag;
use super::deserialiser::DeserError;
use super::deserialiser::Deserialiser;
use super::deserialiser::DeserialiserNode;
use super::deserialiser::FromProof;
use super::deserialiser::Partial;
use super::deserialiser::Result;
use super::deserialiser::Suspended;
use crate::storage::Hash;

/// Wrapper type over the raw byte data to parse tags.
pub struct TagIter<'t> {
    buffered_tags: VecDeque<Result<Tag, DeserialiseError>>,
    raw_data_iter: std::io::Cursor<&'t [u8]>,
}

impl Iterator for TagIter<'_> {
    type Item = Result<Tag, DeserialiseError>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.buffered_tags.is_empty() {
            // We have to consume the next byte
            let mut next_byte = [0u8];
            let byte = match self.raw_data_iter.read_exact(&mut next_byte) {
                Ok(()) => next_byte[0],
                Err(_eof) => return None,
            };

            let tags = Tag::ordered_tags_from_u8(byte);

            self.buffered_tags.append(&mut tags.into());
        }

        self.buffered_tags.pop_front()
    }
}

impl<'i> TagIter<'i> {
    /// Create a [`TagIter`] from a `&[u8]`
    pub fn new(raw_data: &'i [u8]) -> Self {
        TagIter {
            buffered_tags: VecDeque::new(),
            raw_data_iter: std::io::Cursor::new(raw_data),
        }
    }

    /// Convert the remaining unparsed bytes as a [`StreamInput`] for further deserialising.
    pub fn remaining_to_stream_input(&self) -> StreamInput<'_> {
        StreamInput {
            // This clone only copies the reference and the position, not the whole byte array.
            cursor: self.raw_data_iter.clone(),
        }
    }
}

/// Input used for the suspended computation generated by [`StreamDeserialiser`]
pub struct StreamInput<'t> {
    cursor: std::io::Cursor<&'t [u8]>,
}

impl StreamInput<'_> {
    /// Interpret the next bytes as `T` using [`DeserializeOwned`].
    fn deserialise<T: DeserializeOwned>(&mut self) -> Result<T> {
        Ok(crate::storage::binary::deserialise_from(&mut self.cursor)?)
    }
}

// Can only first be parsed to get shape data
// Only after it can be used to obtain DummyInput
#[derive(Clone)]
pub enum StreamDeserialiser<'f, 't> {
    /// Deserialising over an absent tree.
    Absent,
    /// Deserialising over a present tree.
    ///
    /// Phantom data is needed to track 'f lifetime - in order to track the 'f uses
    /// of [`StreamParserComb`] & [`StreamBranchComb`] in this enum's impl blocks.
    Present {
        tags: Rc<RefCell<TagIter<'t>>>,
        _pd: PhantomData<StreamParserComb<'f, 't, ()>>,
    },
}

impl<'f, 't> Deserialiser<'f> for StreamDeserialiser<'f, 't> {
    type Suspended<R: 'f> = StreamParserComb<'f, 't, R>;

    type DeserialiserNode<R: 'f> = StreamBranchComb<'f, 't, R>;

    fn into_leaf_raw<const LEN: usize>(self) -> Result<Self::Suspended<Partial<Box<[u8; LEN]>>>> {
        let tag = match self.next_tag() {
            None => {
                return Ok(StreamParserComb::new(|_| Ok(Partial::Absent)));
            }
            Some(tag) => tag?,
        };

        Ok(StreamParserComb::new(match tag {
            Tag::Node => return Err(DeserError::UnexpectedNode),
            Tag::Leaf(leaf_type) => move |input: &mut StreamInput| match leaf_type {
                LeafTag::Blind => Ok(Partial::Blinded(input.deserialise::<Hash>()?)),
                LeafTag::Read => {
                    let mut data = Box::new([0_u8; LEN]);
                    match input.cursor.read_exact(data.as_mut()) {
                        Ok(()) => Ok(Partial::Present(data)),
                        Err(_eof) => Err(DeserialiseError::NotEnoughBytes.into()),
                    }
                }
            },
        }))
    }

    fn into_leaf<T: DeserializeOwned + 'f>(self) -> Result<Self::Suspended<Partial<T>>> {
        let tag = match self.next_tag() {
            None => {
                return Ok(StreamParserComb::new(|_| Ok(Partial::Absent)));
            }
            Some(tag) => tag?,
        };

        Ok(StreamParserComb::new(match tag {
            Tag::Node => return Err(DeserError::UnexpectedNode),
            Tag::Leaf(leaf_type) => move |input: &mut StreamInput| match leaf_type {
                LeafTag::Blind => Ok(Partial::Blinded(input.deserialise::<Hash>()?)),
                LeafTag::Read => Ok(Partial::Present(input.deserialise::<T>()?)),
            },
        }))
    }

    fn into_node(self) -> Result<Self::DeserialiserNode<Partial<()>>> {
        let tags = match self {
            StreamDeserialiser::Absent => {
                return Ok(StreamBranchComb {
                    f: Box::new(|_| Ok(Partial::Absent)),
                    node_state: None,
                });
            }
            StreamDeserialiser::Present { tags, _pd } => tags,
        };

        let tag = tags
            .borrow_mut()
            .next()
            .ok_or(DeserialiseError::NotEnoughBytes)??;

        enum BlindOrNode {
            Blind,
            Node,
        }

        let branch_case = match tag {
            Tag::Node => BlindOrNode::Node,
            Tag::Leaf(LeafTag::Blind) => BlindOrNode::Blind,
            Tag::Leaf(LeafTag::Read) => return Err(DeserError::UnexpectedLeaf),
        };

        let node_state = match branch_case {
            BlindOrNode::Node => Some(tags),
            BlindOrNode::Blind => None,
        };

        let f = Box::new(move |input: &mut StreamInput| match branch_case {
            BlindOrNode::Node => Ok(Partial::Present(())),
            BlindOrNode::Blind => Ok(Partial::Blinded(input.deserialise()?)),
        });

        Ok(StreamBranchComb { f, node_state })
    }
}

impl<'t> StreamDeserialiser<'_, 't> {
    /// Create a new [`StreamDeserialiser::Present`] with the given tags.
    pub fn new_present(tags: Rc<RefCell<TagIter<'t>>>) -> Self {
        StreamDeserialiser::Present {
            tags,
            _pd: PhantomData,
        }
    }

    /// Obtain next tag.
    ///
    /// Return [`None`] is the father node is absent / blinded and obtaining a tag doesn't make sense.
    fn next_tag(&self) -> Option<Result<Tag, DeserialiseError>> {
        // Panic: Never actually panics because the borrow is first used only while deserialising,
        // and then it is used when running the Suspended computation
        match self {
            StreamDeserialiser::Absent => None,
            StreamDeserialiser::Present { tags, _pd } => Some(match tags.borrow_mut().next() {
                None => Err(DeserialiseError::NotEnoughBytes),
                Some(tag) => tag,
            }),
        }
    }
}

/// Parser combinator for [`StreamDeserialiser`] deserialiser.
pub struct StreamParserComb<'f, 't, R> {
    #[expect(clippy::type_complexity)]
    f: Box<dyn FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'f>,
    _pd: PhantomData<fn(StreamInput<'t>)>,
}

impl<'f, 't, R: 'f> Suspended<'f> for StreamParserComb<'f, 't, R> {
    type Output = R;

    type Parent = StreamDeserialiser<'f, 't>;

    fn map<T>(
        self,
        map_f: impl FnOnce(Self::Output) -> T + 'f,
    ) -> <Self::Parent as Deserialiser<'f>>::Suspended<T>
    where
        T: 'f,
        Self::Output: 'f,
    {
        StreamParserComb::new(move |input| {
            let r = (self.f)(input)?;
            Ok(map_f(r))
        })
    }

    fn zip<T>(
        self,
        other: <Self::Parent as Deserialiser<'f>>::Suspended<T>,
    ) -> <Self::Parent as Deserialiser<'f>>::Suspended<(Self::Output, T)>
    where
        Self::Output: 'f,
        T: 'f,
    {
        StreamParserComb::new(|input| {
            let r = (self.f)(input)?;
            let t = (other.f)(input)?;
            Ok((r, t))
        })
    }
}

impl<'f, R> StreamParserComb<'f, '_, R> {
    /// Create a new [`StreamParserComb`] with the given function.
    pub fn new(f: impl FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'f) -> Self {
        StreamParserComb {
            f: Box::new(f),
            _pd: PhantomData,
        }
    }
}

/// Branch combinator for [`StreamDeserialiser`] deserialiser.
pub struct StreamBranchComb<'f, 't, R> {
    #[expect(clippy::type_complexity)]
    f: Box<dyn FnOnce(&mut StreamInput) -> Result<R, DeserError> + 'f>,
    /// The none case represents that the father node was blind or absent.
    node_state: Option<Rc<RefCell<TagIter<'t>>>>,
}

impl<'f, 't, R: 'f> DeserialiserNode<'f, R> for StreamBranchComb<'f, 't, R> {
    type Parent = StreamDeserialiser<'f, 't>;

    fn next_branch<T>(
        self,
        branch_deserialiser: impl FnOnce(
            Self::Parent,
        )
            -> Result<<Self::Parent as Deserialiser<'f>>::Suspended<T>>
        + 'f,
    ) -> Result<<Self::Parent as Deserialiser<'f>>::DeserialiserNode<(R, T)>>
    where
        T: 'f,
        R: 'f,
    {
        let child_proof = match &self.node_state {
            Some(tags) => StreamDeserialiser::new_present(tags.clone()),
            None => StreamDeserialiser::Absent,
        };
        let next_branch_fn = branch_deserialiser(child_proof)?;

        Ok(StreamBranchComb {
            f: Box::new(move |input| {
                // We still have to apply the parser combinator, it may compute the Hash for the blinded case for example
                // or any other intermediate function the user made on the computation using `map`
                let r = (self.f)(input)?;

                // The same logic applies for the child branch, maybe the user maps the Absent result to something else.
                let br_res = (next_branch_fn.f)(input)?;

                Ok((r, br_res))
            }),
            node_state: self.node_state,
        })
    }

    fn map<T>(
        self,
        f: impl FnOnce(R) -> T + 'f,
    ) -> <Self::Parent as Deserialiser<'f>>::DeserialiserNode<T>
    where
        T: 'f,
        R: 'f,
    {
        StreamBranchComb {
            f: Box::new(move |input| Ok(f((self.f)(input)?))),
            node_state: self.node_state,
        }
    }

    fn done(self) -> Result<<Self::Parent as Deserialiser<'f>>::Suspended<R>> {
        Ok(StreamParserComb::new(self.f))
    }
}

impl<R> StreamParserComb<'_, '_, R> {
    pub fn into_result(self, input: &mut StreamInput) -> Result<R> {
        let result = (self.f)(input);

        // A correct deserialisation makes sure all bytes are consumed.
        // Otherwise, if tags dictate more a bigger part of the proof has been blinded then
        // the extra data at the end which wasn't actually blinded remains unparsed / ignored.

        // XXX: has_data_left() can be used, but it is a nightly feature
        // tracking issue: <https://github.com/rust-lang/rust/issues/86423>
        let mut next_byte = [0_u8];
        match input.cursor.read_exact(&mut next_byte) {
            Ok(()) => Err(DeserError::RemainingBytes),
            Err(_eof) => result,
        }
    }
}

/// Deserialise into a type `T::Output` given the raw bytes.
///
/// Convenience function to bundle deserialisation and execution of the suspended function for the owned deserialisation.
pub fn deserialise<T: FromProof>(proof_tree_raw_bytes: &[u8]) -> Result<T::Output> {
    let tags_rc = Rc::new(RefCell::new(TagIter::new(proof_tree_raw_bytes)));
    let comp_fn = T::from_proof(StreamDeserialiser::new_present(tags_rc.clone()))?;

    // SAFETY: The `Deserialiser` trait provided to the `FromProof` implementation of T
    // can not execute the suspended computation, it can only compose them due to encapsulation
    (comp_fn.f)(&mut tags_rc.borrow_mut().remaining_to_stream_input())
}
